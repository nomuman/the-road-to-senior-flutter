{
  "f1": [
    { "question": "DartのNull Safetyでない型にnullを代入するとどうなりますか？", "options": ["実行時エラー", "コンパイルエラー", "警告が表示される", "何も起こらない"], "correctAnswer": 1, "explanation": "Null Safetyが有効なDartでは、non-nullableな型にnullを代入しようとするとコンパイル時にエラーとなります。" },
    { "question": "Dartで定数を宣言するキーワードは `const` と何ですか？", "options": ["static", "let", "final", "var"], "correctAnswer": 2, "explanation": "`final`は実行時に値が決定する定数を宣言し、`const`はコンパイル時に値が決定する定数を宣言します。" },
    { "question": "Dartの非同期処理で、未来のある時点で結果を返すオブジェクトは何ですか？", "options": ["Stream", "Async", "Future", "Callback"], "correctAnswer": 2, "explanation": "Futureは、非同期操作の結果を表します。成功した場合は値を、失敗した場合はエラーを返します。" },
    { "question": "List<int>型の変数に文字列を追加しようとするとどうなりますか？", "options": ["実行時エラー", "コンパイルエラー", "自動的に型変換される", "無視される"], "correctAnswer": 1, "explanation": "Dartは静的型付け言語なので、List<int>にint以外の型を追加しようとするとコンパイルエラーになります。" },
    { "question": "Dartにおける `=>` (アロー構文) はどのような場合に使えますか？", "options": ["複数行の関数", "単一の式のみを返す関数", "クラスのコンストラクタ", "非同期関数"], "correctAnswer": 1, "explanation": "アロー構文は、単一の式を評価して返す関数のシンタックスシュガーです。" },
    { "question": "Dartの `late` キーワードの主な目的は何ですか？", "options": ["変数を遅延初期化する", "変数をnull許容にする", "変数をプライベートにする", "変数を静的にする"], "correctAnswer": 0, "explanation": "`late` は、変数が使用される直前まで初期化を遅らせることを示します。これにより、non-nullableな変数を宣言時に初期化できない場合に役立ちます。" },
    { "question": "コレクション(List, Map, Set)の要素をループ処理するのに最も推奨される方法はどれですか？", "options": ["C-style forループ", "for-inループ", "forEachメソッド", "whileループ"], "correctAnswer": 1, "explanation": "for-inループ (`for (var item in collection)`) は、可読性が高く、インデックスエラーの心配がないため、コレクションのループ処理に最も推奨されます。" },
    { "question": "Dartの `mixin` の説明として最も適切なものはどれですか？", "options": ["クラスの多重継承を可能にする", "コードを再利用するための方法で、クラスの機能を複数のクラス階層で共有できる", "静的メソッドのみを持つクラス", "インターフェースを実装するためのキーワード"], "correctAnswer": 1, "explanation": "Mixinは、`extends`による継承とは別に、クラスに機能を追加する方法です。`with`キーワードを使ってクラスにMixinを適用します。" },
    { "question": "非同期処理の連続したイベント(データストリーム)を扱うためのオブジェクトは何ですか？", "options": ["Future", "Isolate", "Stream", "Generator"], "correctAnswer": 2, "explanation": "Streamは、非同期イベントのシーケンスを提供します。ファイルの読み込み、ユーザーのUIイベントなど、複数の値を時間経過とともに受け取るのに使われます。" },
    { "question": "Dartの `?.` (null-aware operator) はどのような働きをしますか？", "options": ["オブジェクトがnullでなければ、そのプロパティやメソッドにアクセスする", "オブジェクトがnullの場合、デフォルト値を返す", "オブジェクトがnullかチェックする", "オブジェクトをnull非許容に変換する"], "correctAnswer": 0, "explanation": "Null-aware operator (`?.`) は、レシーバーがnullでない場合にのみ、その後のプロパティやメソッドの呼び出しを実行します。レシーバーがnullの場合は、式全体がnullを返します。" }
  ],
  "f2": [
    { "question": "状態を持つWidgetはどちらですか？", "options": ["StatelessWidget", "StatefulWidget", "Both", "Neither"], "correctAnswer": 1, "explanation": "StatefulWidgetは、そのライフサイクル中に変化する可能性のある状態（State）を保持します。" },
    { "question": "StatelessWidgetの `build` メソッドは何を返すべきですか？", "options": ["State", "void", "Widget", "BuildContext"], "correctAnswer": 2, "explanation": "`build` メソッドは、UIを構成するWidgetツリーを返す必要があります。" },
    { "question": "StatefulWidgetで状態が変化したときにUIを再描画するために呼び出すメソッドは何ですか？", "options": ["rebuild()", "update()", "build()", "setState()"], "correctAnswer": 3, "explanation": "`setState()` を呼び出すと、フレームワークに変更を通知し、`build` メソッドが再実行されてUIが更新されます。" },
    { "question": "`BuildContext` の主な役割は何ですか？", "options": ["Widgetツリー内でのWidgetの位置を特定する", "アセットへのアクセスを提供する", "状態管理を行う", "アニメーションを制御する"], "correctAnswer": 0, "explanation": "`BuildContext` は、Widgetツリー内での各Widgetの場所をハンドルし、`Provider.of(context)` のように親Widgetを検索するために使用されます。" },
    { "question": "Flutterの「宣言的UI」とはどういう意味ですか？", "options": ["UIの見た目をステップバイステップで命令的に変更する", "現在のアプリケーションの状態に基づいてUIがどうあるべきかを記述する", "UIをXMLファイルで定義する", "UIの各要素を手動で描画する"], "correctAnswer": 1, "explanation": "宣言的UIでは、現在の状態に対応するUIを記述します。状態が変化すると、フレームワークが自動的にUIを新しい状態に更新します。" },
    { "question": "StatefulWidgetのライフサイクルで、`build` メソッドの前に一度だけ呼ばれるメソッドは何ですか？", "options": ["constructor", "initState()", "didUpdateWidget()", "dispose()"], "correctAnswer": 1, "explanation": "`initState()` は、Widgetがツリーに挿入されたときに一度だけ呼び出されます。初期化処理（Streamの購読など）に適しています。" },
    { "question": "Widgetがツリーから完全に取り除かれる際に呼ばれるメソッドで、リソースの解放などを行うのはどれですか？", "options": ["deactivate()", "dispose()", "didChangeDependencies()", "finalize()"], "correctAnswer": 1, "explanation": "`dispose()` は、Stateオブジェクトが永久に破棄される際に呼び出されます。コントローラーの破棄やStreamのキャンセルなど、クリーンアップ処理をここで行います。" },
    { "question": "StatelessWidgetが再構築されるのはどのような場合ですか？", "options": ["内部状態が変化したとき", "親Widgetが再構築されたとき", "ユーザーが画面をタップしたとき", "StatelessWidgetは再構築されない"], "correctAnswer": 1, "explanation": "StatelessWidgetは不変ですが、親Widgetから異なる引数で再構築されるか、親自体が再構築されると、その `build` メソッドが再実行されます。" },
    { "question": "FlutterのWidgetツリーは主に3つのツリーから構成されます。`Widget`、`Element`、あと一つは何ですか？", "options": ["State Tree", "Component Tree", "RenderObject Tree", "Layout Tree"], "correctAnswer": 2, "explanation": "Flutterは、Widgetツリー（設定）、Elementツリー（インスタンス）、RenderObjectツリー（描画）の3つの主要なツリーを使用してUIを効率的に管理・描画します。" },
    { "question": "`Key` をWidgetに渡す主な目的は何ですか？", "options": ["WidgetにユニークなIDを与える", "Widgetのパフォーマンスを向上させる", "同じ型のWidgetのリストを再構築する際に、状態を保持し効率的に更新する", "Widgetの見た目を変更する"], "correctAnswer": 2, "explanation": "Key、特に `GlobalKey` や `ValueKey` は、同じ型のWidgetが複数ある場合に、FlutterがElementとStateを正しく関連付けるのを助けます。これにより、リストの要素を並べ替えたり削除したりする際のパフォーマンスが向上します。" }
  ],
  "f3": [
    { "question": "子Widgetを縦に並べるにはどのWidgetを使いますか？", "options": ["Row", "Stack", "Column", "Container"], "correctAnswer": 2, "explanation": "Columnは子Widgetを垂直方向に並べるためのレイアウトWidgetです。" },
    { "question": "`Row` Widgetの主軸(main axis)はどちらの方向ですか？", "options": ["垂直方向", "水平方向", "Z軸方向", "状況による"], "correctAnswer": 1, "explanation": "`Row` は子Widgetを水平方向に並べるため、その主軸は水平方向です。" },
    { "question": "`Column` の中で子Widgetを水平方向の中央に配置するには、どのプロパティを使いますか？", "options": ["mainAxisAlignment", "crossAxisAlignment", "mainAxisSize", "verticalDirection"], "correctAnswer": 1, "explanation": "`Column` の交差軸(cross axis)は水平方向です。したがって、`crossAxisAlignment: CrossAxisAlignment.center` を使用します。" },
    { "question": "複数のWidgetを重ねて表示したい場合に最も適したレイアウトWidgetはどれですか？", "options": ["Column", "Row", "Stack", "Wrap"], "correctAnswer": 2, "explanation": "`Stack` は、子WidgetをZ軸方向（手前から奥）に重ねて配置することができます。`Positioned` と組み合わせて使うことが多いです。" },
    { "question": "Widgetの周囲に余白(空白)を追加するために最も一般的に使われるWidgetはどれですか？", "options": ["Container", "SizedBox", "Padding", "Margin"], "correctAnswer": 2, "explanation": "`Padding` Widgetは、子Widgetの周囲に指定した値のパディング（内側の余白）を追加します。" },
    { "question": "`Container` Widgetで背景色とパディングを同時に設定することは可能ですか？", "options": ["はい", "いいえ"], "correctAnswer": 0, "explanation": "はい、`Container` は `color` プロパティで背景色を、`padding` プロパティで内部の余白を、`margin` プロパティで外部の余白を設定できる非常に便利なWidgetです。" },
    { "question": "画面サイズに応じてレイアウトを調整したい場合に役立つWidgetはどれですか？", "options": ["Expanded", "Flexible", "MediaQuery", "LayoutBuilder"], "correctAnswer": 3, "explanation": "`LayoutBuilder` は、親Widgetが子に与える制約(constraints)を基にUIを構築できます。これにより、利用可能なスペースに応じて動的にレイアウトを変更できます。" },
    { "question": "`Row` や `Column` の中で、特定の子Widgetに残りのスペースをすべて割り当てるにはどのWidgetでラップしますか？", "options": ["SizedBox", "Expanded", "FittedBox", "AspectRatio"], "correctAnswer": 1, "explanation": "`Expanded` Widgetは、`Row`, `Column`, `Flex` の子として使用され、主軸方向の利用可能なスペースをすべて占有するように子を拡張します。" },
    { "question": "テキストやアイコンがコンテナの境界をはみ出してしまうのを防ぐために使えるWidgetはどれですか？", "options": ["OverflowBox", "FittedBox", "ClipRect", "SizedBox"], "correctAnswer": 1, "explanation": "`FittedBox` は、子Widgetを親Widgetのサイズに合わせて拡大・縮小します。これにより、コンテンツのはみ出しを防ぐことができます。" },
    { "question": "`ListView` と `Column` の主な違いは何ですか？", "options": ["`ListView` は水平方向にしか配置できない", "`Column` はスクロールできないが、`ListView` は自動的にスクロール可能になる", "`ListView` は子Widgetを1つしか持てない", "違いはない"], "correctAnswer": 1, "explanation": "`Column` はすべての子Widgetを一度にレンダリングし、画面に収まらない場合はオーバーフローエラーになります。一方、`ListView` は画面に表示されているアイテムのみをレンダリングするため、大量の要素を効率的に表示できます。" }
  ],
  "f4": [
    { "question": "Flutterで新しい画面に遷移するために最も一般的に使われるメソッドは何ですか？", "options": ["Navigator.push()", "Navigator.go()", "Navigator.open()", "Navigator.next()"], "correctAnswer": 0, "explanation": "`Navigator.push()` は、新しいルート（画面）をナビゲーションスタックの一番上に積みます。" },
    { "question": "現在の画面を閉じて前の画面に戻るために呼び出すメソッドは何ですか？", "options": ["Navigator.pop()", "Navigator.back()", "Navigator.close()", "Navigator.remove()"], "correctAnswer": 0, "explanation": "`Navigator.pop()` は、ナビゲーションスタックの一番上のルートを取り除き、その下の画面を表示します。" },
    { "question": "画面遷移時にデータを次の画面に渡すにはどうすればよいですか？", "options": ["グローバル変数を使う", "`MaterialPageRoute` の `arguments` を使う", "`Navigator.push()` に直接データを渡す", "データベースに保存する"], "correctAnswer": 1, "explanation": "ルート（例: `MaterialPageRoute`）のコンストラクタにある `settings` プロパティ（`RouteSettings`）の `arguments` を使って、次の画面にデータを渡すのが一般的です。" },
    { "question": "名前付きルート(Named Routes)の利点は何ですか？", "options": ["パフォーマンスが向上する", "コードの可読性が向上し、ナビゲーションロジックを一元管理できる", "アニメーションをカスタマイズできる", "常に新しい画面として開かれる"], "correctAnswer": 1, "explanation": "名前付きルートを使うと、`Navigator.pushNamed('/details')` のように文字列で遷移先を指定でき、`MaterialApp` の `routes` プロパティでルート定義を一元管理できます。" },
    { "question": "現在の画面を新しい画面に置き換える（スタックから現在の画面を削除する）には、どのメソッドを使いますか？", "options": ["Navigator.replace()", "Navigator.pushReplacement()", "Navigator.swap()", "Navigator.change()"], "correctAnswer": 1, "explanation": "`Navigator.pushReplacement()` は、現在のルートを新しいルートに置き換えます。スプラッシュスクリーンからホーム画面への遷移などでよく使われます。" },
    { "question": "モーダルダイアログを表示するために使われる関数は何ですか？", "options": ["showDialog()", "openDialog()", "displayModal()", "createPopup()"], "correctAnswer": 0, "explanation": "`showDialog()` 関数は、モーダルダイアログを画面の上にオーバーレイ表示します。これはナビゲーションスタックに新しいルートを追加します。" },
    { "question": "ボトムシートを表示するために使われる関数は何ですか？", "options": ["showBottomSheet()", "showModalBottomSheet()", "どちらも", "どちらでもない"], "correctAnswer": 2, "explanation": "`showBottomSheet` は永続的なボトムシートを、`showModalBottomSheet` はモーダル（画面の他の部分を操作できなくする）なボトムシートを表示します。" },
    { "question": "`WillPopScope` Widgetの主な目的は何ですか？", "options": ["画面遷移を高速化する", "Androidの「戻る」ボタンの挙動を制御する", "画面遷移のアニメーションを変更する", "次の画面にデータを渡す"], "correctAnswer": 1, "explanation": "`WillPopScope` を使うと、ユーザーがナビゲーションスタックからルートをポップしようとしたとき（例: Androidの戻るボタンを押したとき）の動作をインターセプトし、独自のロジック（例: 確認ダイアログの表示）を実行できます。" },
    { "question": "`Hero` Widgetは何のために使われますか？", "options": ["主要なボタンを目立たせるため", "画面遷移時にWidgetをスムーズにアニメーションさせるため", "画像をキャッシュするため", "アプリのアイコンを設定するため"], "correctAnswer": 1, "explanation": "`Hero` Widgetは、異なる画面にある同じ `tag` を持つWidget間をスムーズにアニメーションさせる（ヒーローアニメーション）ために使われます。" },
    { "question": "`MaterialApp` の `onGenerateRoute` コールバックは何のために使われますか？", "options": ["アプリ起動時に呼ばれる", "`routes` テーブルにない名前付きルートが要求されたときに動的にルートを生成する", "すべての画面遷移をログに記録する", "画面遷移のエラーを処理する"], "correctAnswer": 1, "explanation": "`onGenerateRoute` は、名前付きルートでの画面遷移で、`routes` マップに定義されていないルートが要求された場合に、その場でルートを生成するための強力な仕組みです。" }
  ],
  "f5": [
    { "question": "ユーザーからのテキスト入力を受け付けるための最も基本的なWidgetは何ですか？", "options": ["Text", "FormField", "InputBox", "TextField"], "correctAnswer": 3, "explanation": "`TextField` は、ユーザーがキーボードでテキストを入力するための基本的なWidgetです。" },
    { "question": "`TextField` の入力内容を取得・制御するために使われるオブジェクトは何ですか？", "options": ["TextController", "InputController", "TextEditingController", "StringController"], "correctAnswer": 2, "explanation": "`TextEditingController` を `TextField` の `controller` プロパティに設定することで、プログラム的にテキストを読み書きしたり、入力を監視したりできます。" },
    { "question": "複数の入力フィールドをまとめて管理し、バリデーションや保存を行うためのWidgetは何ですか？", "options": ["Form", "InputGroup", "FieldCollection", "Validator"], "correctAnswer": 0, "explanation": "`Form` Widgetは、その子孫である `FormField` Widgetをグループ化し、それらの状態を一括で検証(validate)・保存(save)・リセット(reset)することができます。" },
    { "question": "`TextFormField` の `validator` プロパティが返す値は何ですか？", "options": ["bool (有効かどうか)", "Widget (エラーメッセージ)", "String? (エラーメッセージ、有効な場合はnull)", "void"], "correctAnswer": 2, "explanation": "`validator` コールバックは、入力が有効な場合は `null` を、無効な場合はエラーメッセージとして表示される `String` を返す必要があります。" },
    { "question": "フォームのすべての `FormField` の `onSaved` メソッドを一度に呼び出すには、`FormState` のどのメソッドを使いますか？", "options": ["validate()", "save()", "reset()", "submit()"], "correctAnswer": 1, "explanation": "`Form.of(context).save()` または `_formKey.currentState.save()` を呼び出すと、フォーム内のすべての `TextFormField` の `onSaved` コールバックが実行されます。" },
    { "question": "パスワード入力用の `TextField` を作成するには、どのプロパティを `true` に設定しますか？", "options": ["password", "secret", "obscureText", "hideText"], "correctAnswer": 2, "explanation": "`obscureText: true` を設定すると、入力されたテキストがドットなどの文字で隠されます。" },
    { "question": "`TextField` の見た目（枠線、ラベル、ヒントなど）をカスタマイズするには、どのプロパティを使いますか？", "options": ["style", "decoration", "design", "appearance"], "correctAnswer": 1, "explanation": "`decoration` プロパティに `InputDecoration` オブジェクトを渡すことで、ラベルテキスト、ヒントテキスト、アイコン、枠線のスタイルなどを細かく設定できます。" },
    { "question": "ユーザーがキーボードのエンターキー（実行ボタン）を押したときに呼ばれるコールバックはどれですか？", "options": ["onChanged", "onEditingComplete", "onSubmitted", "onTap"], "correctAnswer": 2, "explanation": "`onSubmitted` は、ユーザーがキーボードのアクションボタン（完了、送信など）を押して入力を確定したときに呼び出されます。" },
    { "question": "チェックボックスの状態を管理するために最も適したWidgetはどれですか？", "options": ["StatefulWidget", "Checkbox", "CheckboxListTile", "StatelessWidget"], "correctAnswer": 2, "explanation": "`CheckboxListTile` は、チェックボックスとそのラベル、タップ領域を組み合わせた便利なWidgetで、`value` と `onChanged` を使って状態を管理します。" },
    { "question": "ドロップダウンメニューから項目を選択させるためのWidgetは何ですか？", "options": ["Select", "OptionMenu", "DropdownButton", "PopupMenuButton"], "correctAnswer": 2, "explanation": "`DropdownButton` は、タップすると選択肢のリストを表示し、ユーザーが1つを選ぶことができるUIコンポーネントです。" }
  ],
  "a1": [
    { "question": "FlutterでUIの状態を更新するために `StatefulWidget` 内で呼び出すメソッドは何ですか？", "options": ["update()", "refresh()", "setState()", "build()"], "correctAnswer": 2, "explanation": "`setState()` を呼び出すことで、フレームワークに変更があったことを伝え、UIの再描画をトリガーします。" },
    { "question": "親Widgetから深い階層の子Widgetにデータを渡す際に、中間のWidgetがデータをただ中継するだけの問題は何と呼ばれますか？", "options": ["State Lifting", "Callback Drilling", "Prop Drilling", "Widget Injection"], "correctAnswer": 2, "explanation": "Prop Drilling（またはProperty Drilling）は、状態管理ライブラリを使わない場合に発生しがちな問題で、コードの可読性と保守性を低下させます。" },
    { "question": "状態管理の主な目的として、最も適切なものはどれですか？", "options": ["アプリのパフォーマンスを向上させる", "UIコードとビジネスロジックを分離する", "Widgetの数を減らす", "アプリのビルド時間を短縮する"], "correctAnswer": 1, "explanation": "状態管理は、UIの描画ロジックと、データの取得や加工といったビジネスロジックを分離することで、コードを整理し、テストや保守を容易にすることを目的とします。" },
    { "question": "「単方向データフロー」アーキテクチャの利点は何ですか？", "options": ["コードの記述量が減る", "データの流れが予測可能になり、デバッグが容易になる", "UIの更新が高速になる", "双方向のデータバインディングが可能になる"], "correctAnswer": 1, "explanation": "データが一方向に（例: UI → BLoC → State → UI）流れることで、状態の変化がどこで発生し、どのようにUIに反映されるかが明確になり、追跡しやすくなります。" },
    { "question": "アプリケーション全体で共有される状態（例: ユーザーのログイン情報）を何と呼びますか？", "options": ["Local State (ローカル状態)", "Ephemeral State (短命な状態)", "App State (アプリ状態)", "Widget State (ウィジェット状態)"], "correctAnswer": 2, "explanation": "App State（またはGlobal State）は、多くの画面や機能で共有され、ユーザーセッションを通じて保持される状態を指します。" },
    { "question": "`setState()` のみで大規模なアプリの状態を管理する場合の主な欠点は何ですか？", "options": ["非同期処理が扱えない", "状態の変更がどこからでも行えてしまい、追跡が困難になる", "UIの更新が遅い", "テストコードが書けない"], "correctAnswer": 1, "explanation": "`setState()` はシンプルですが、ロジックがUIコードに散らばり、状態の変更がどこで起こったのかを追跡するのが難しくなりがちです。" },
    { "question": "状態管理ライブラリを導入する主な動機は何ですか？", "options": ["Flutterの標準機能だけでは実現できないUIを作成するため", "コードの構造化、テスト容易性の向上、保守性の確保のため", "アプリの見た目を良くするため", "ネイティブ機能との連携を容易にするため"], "correctAnswer": 1, "explanation": "アプリが複雑になるにつれて、状態管理ライブラリはコードを整理し、チームでの開発を円滑にするための強力なツールとなります。" },
    { "question": "「状態(State)」とは、Flutterにおいて何を指しますか？", "options": ["Widgetの見た目", "特定の時点でのアプリケーションのデータ", "ユーザーが行う操作", "データベース"], "correctAnswer": 1, "explanation": "状態とは、アプリケーションの振る舞いやUIの表示に影響を与える、時間とともに変化する可能性のあるデータ全般を指します。" },
    { "question": "UIとロジックを分離することの直接的なメリットは何ですか？", "options": ["UIデザイナーと開発者が並行して作業しやすくなる", "ロジック部分をUIとは独立して単体テストできる", "両方の選択肢", "どちらでもない"], "correctAnswer": 2, "explanation": "UIとロジックを分離することで、それぞれを独立して開発・テストできるようになり、コードの再利用性や保守性が向上します。" },
    { "question": "状態管理パターンを選択する際に考慮すべきでない要素はどれですか？", "options": ["チームのスキルセットと習熟度", "アプリケーションの規模と複雑さ", "コミュニティの活発さとドキュメントの充実度", "アルファベット順で一番最初のライブラリ"], "correctAnswer": 3, "explanation": "状態管理の選択はプロジェクトの成功に大きく影響します。アプリの要件やチームの状況に合わせて、BLoC, Riverpod, Providerなどから適切なものを選択することが重要です。" }
  ],
  "a2": [
    { "question": "`Provider` パッケージで、状態が変化したことをリスナーに通知するために使われるクラスは何ですか？", "options": ["StateNotifier", "ChangeNotifier", "ValueNotifier", "StateProvider"], "correctAnswer": 1, "explanation": "`ChangeNotifier` を `with` または `extends` したクラス内で `notifyListeners()` を呼び出すと、その変更をリッスンしているWidgetに通知できます。" },
    { "question": "UI側で `ChangeNotifier` の変更をリッスンし、UIを再構築するために使われるWidgetは何ですか？", "options": ["Listener", "Provider.of", "Consumer", "Builder"], "correctAnswer": 2, "explanation": "`Consumer` Widgetを使うと、Providerが提供するオブジェクトの変更をリッスンし、変更があった部分だけを効率的に再構築できます。" },
    { "question": "`ChangeNotifierProvider` の主な役割は何ですか？", "options": ["`ChangeNotifier` のインスタンスを生成し、そのライフサイクルを管理する", "`ChangeNotifier` のインスタンスを破棄する", "UIを構築する", "状態を永続化する"], "correctAnswer": 0, "explanation": "`ChangeNotifierProvider` は、`ChangeNotifier` のインスタンスをWidgetツリーに提供し、不要になったときに自動的に `dispose()` を呼び出してリソースを解放します。" },
    { "question": "`Provider.of<T>(context, listen: false)` はどのような場合に使いますか？", "options": ["状態の変更に応じてUIを更新したい場合", "状態の変更はリッスンせず、一度だけ値を取得したり、メソッドを呼び出したりしたい場合", "常にUIを更新したい場合", "そのような使い方は存在しない"], "correctAnswer": 1, "explanation": "`listen: false` を設定すると、Providerの値が変更されてもWidgetは再構築されません。`onPressed` コールバック内などでメソッドを呼び出す際に便利です。" },
    { "question": "`ChangeNotifier` を使ったクラスで、状態を変更した後に呼び出すべきメソッドは何ですか？", "options": ["update()", "refresh()", "notifyListeners()", "setState()"], "correctAnswer": 2, "explanation": "`notifyListeners()` を呼び出すことで、この `ChangeNotifier` をリッスンしているすべての `Consumer` や `Provider.of` に変更が通知されます。" },
    { "question": "複数のProviderをWidgetツリーの上位でまとめて提供したい場合、どのWidgetを使いますか？", "options": ["MultiProvider", "ProviderTree", "ProviderList", "ProviderGroup"], "correctAnswer": 0, "explanation": "`MultiProvider` を使うと、ネストが深くなるのを避けつつ、複数のProviderをすっきりと記述できます。" },
    { "question": "`Provider` パッケージは、何の略ですか？", "options": ["DI (Dependency Injection)", "State Management", "InheritedWidget", "特にない"], "correctAnswer": 2, "explanation": "`Provider` は、Flutterの `InheritedWidget` をより使いやすく、再利用しやすくするためのラッパーです。DIコンテナとしても機能します。" },
    { "question": "`Consumer` Widgetと `Provider.of` の使い分けとして、より推奨されるのはどちらですか？", "options": ["常に `Provider.of` を使うべき", "常に `Consumer` を使うべき", "パフォーマンス最適化のため、`Consumer` を使って再構築の範囲を限定することが推奨される", "どちらでも良い"], "correctAnswer": 2, "explanation": "`Consumer` を使うと、変更をリッスンする必要があるWidgetだけをラップできるため、`build` メソッド全体が再実行されるのを防ぎ、パフォーマンスを向上させることができます。" },
    { "question": "`FutureProvider` は何のために使われますか？", "options": ["`Future` の結果をWidgetツリーに提供する", "`Stream` の値をWidgetツリーに提供する", "単純な値をWidgetツリーに提供する", "状態の変更を通知する"], "correctAnswer": 0, "explanation": "`FutureProvider` は、非同期処理（Future）を扱い、その状態（待機中、完了、エラー）に応じてUIを簡単に構築できるようにします。" },
    { "question": "`ProxyProvider` の主な用途は何ですか？", "options": ["Providerのパフォーマンスを監視する", "他のProviderの値に依存して、新しい値を生成する", "Providerを非推奨にする", "Providerの値をキャッシュする"], "correctAnswer": 1, "explanation": "`ProxyProvider` は、他のProviderから受け取った値を基に、動的に新しいオブジェクトを生成して提供します。例えば、ユーザー認証情報(AuthProvider)を使って、ユーザー固有のデータを提供する(ApiProvider)といった場合に便利です。" }
  ],
  "a3": [
      { "question": "BLoCにおいて、UIからの入力を受け取るのは主に何ですか？", "options": ["State", "Event", "Repository", "Widget"], "correctAnswer": 1, "explanation": "UIからのユーザー操作などはEventとしてBlocに渡されます。" },
      { "question": "BlocとCubitの主な違いは何ですか？", "options": ["CubitはEventを使わない", "Blocは状態を持たない", "Cubitは非同期処理ができない", "BlocはWidgetである"], "correctAnswer": 0, "explanation": "Cubitは関数を直接呼び出して状態を更新するシンプルなアプローチで、Eventを定義する必要がありません。" },
      { "question": "flutter_blocで、Blocの状態変化に応じてUIを再構築するWidgetは何ですか？", "options": ["BlocProvider", "BlocListener", "BlocBuilder", "RepositoryProvider"], "correctAnswer": 2, "explanation": "BlocBuilderは、指定されたBlocの状態(State)が変化するたびにUIを再構築します。" },
      { "question": "BLoCパターンにおける「状態(State)」の役割は何ですか？", "options": ["ビジネスロジックを実行する", "UIからの入力を受け取る", "アプリケーションの現在の状態を表す", "外部データソースと通信する"], "correctAnswer": 2, "explanation": "Stateは、特定の時点でのアプリケーションの状態を表現するイミュータブルなオブジェクトです。" },
      { "question": "Cubitで状態を更新する際に呼び出すメソッドは何ですか？", "options": ["add(event)", "emit(state)", "setState()", "update()"], "correctAnswer": 1, "explanation": "Cubit内のメソッドは、新しい状態を `emit()` することでUIに通知します。" },
      { "question": "`BlocListener` の主な目的は何ですか？", "options": ["状態に応じてUIを再構築する", "状態変化に応じて、UIの再構築を伴わない一度きりのアクション（ナビゲーション、ダイアログ表示など）を実行する", "Blocのインスタンスを提供する", "EventをBlocに送信する"], "correctAnswer": 1, "explanation": "`BlocListener` はUIの再構築は行いません。状態の変化をトリガーとして、`Navigator.push` や `ScaffoldMessenger.showSnackBar` などの処理を実行するのに適しています。" },
      { "question": "Blocの `mapEventToState` メソッド（または `on<Event>`）は何を返すべきですか？", "options": ["`Future<void>`", "`Widget`", "`Stream<State>`", "`Event`"], "correctAnswer": 2, "explanation": "このメソッドは、受け取ったEventに基づいて、0個以上の新しいStateを非同期に生成する `Stream` を返します。" },
      { "question": "あるBlocが別のBlocに依存している場合、どのように依存性を注入するのが一般的ですか？", "options": ["グローバル変数を使う", "`BlocProvider` をネストし、コンストラクタで受け取る", "シングルトンパターンを使う", "Blocは他のBlocに依存できない"], "correctAnswer": 1, "explanation": "`BlocProvider` を使って依存関係をWidgetツリー経由で注入するのが、テスト容易性も高く推奨される方法です。" },
      { "question": "`BlocProvider.value` はどのような場合に使用しますか？", "options": ["新しいBlocインスタンスを生成する場合", "既に存在するBlocインスタンスを、ツリーの別の部分に提供する場合", "Blocの値を変更する場合", "Blocを破棄する場合"], "correctAnswer": 1, "explanation": "`BlocProvider.value` は新しいインスタンスを生成せず、既存のインスタンスを提供します。リスト内のアイテムなど、既に存在するBlocを新しいルートに提供する際に便利です。" },
      { "question": "BLoCのテストで、特定のイベントがどのような状態遷移を引き起こすかを検証するために使われるライブラリは何ですか？", "options": ["mockito", "test", "bloc_test", "flutter_test"], "correctAnswer": 2, "explanation": "`bloc_test` パッケージは、`when` で初期状態をスタブし、`expect` で期待される状態のシーケンスを表明するなど、BLoCのテストを簡潔に記述するための便利なAPIを提供します。" }
  ],
  "a4": [
    { "question": "Riverpodで非同期処理の結果を扱うのに適したProviderはどれですか？", "options": ["Provider", "StateProvider", "FutureProvider", "StateNotifierProvider"], "correctAnswer": 2, "explanation": "FutureProviderはFutureをラップし、その状態（loading, data, error）に応じてUIを更新するのに便利です。" },
    { "question": "Riverpodの `ref.watch` と `ref.read` の主な違いは何ですか？", "options": ["`watch` は非同期、`read` は同期", "`watch` はProviderの状態を監視し、変更があればWidgetを再構築するが、`read` は再構築しない", "`read` は値を書き込むために使う", "違いはない"], "correctAnswer": 1, "explanation": "`ref.watch` は `build` メソッド内で使い、Providerの変更に反応します。`ref.read` は `onPressed` コールバック内などで、再構築をトリガーせずに値を取得するために使います。" },
    { "question": "複雑な状態オブジェクトを管理し、その状態を変更するロジックをカプセル化するのに適したProviderはどれですか？", "options": ["Provider", "StateProvider", "FutureProvider", "StateNotifierProvider"], "correctAnswer": 3, "explanation": "`StateNotifierProvider` は、`StateNotifier` クラスと組み合わせて使います。`StateNotifier` は、イミュータブルな状態を管理し、状態変更ロジックをクラス内にまとめるのに適しています。" },
    { "question": "Providerの `.autoDispose` 修飾子は何をしますか？", "options": ["Providerを自動的に破棄する", "Providerの状態をリッスンしているWidgetがなくなったら、自動的に状態を破棄する", "Providerのキャッシュを無効にする", "Providerを非同期にする"], "correctAnswer": 1, "explanation": "`.autoDispose` を付けると、Providerがリッスンされなくなったときにその状態が破棄されます。不要なメモリ使用を防ぎ、状態をクリーンに保つのに役立ちます。" },
    { "question": "あるProviderが別のProviderの値を必要とする場合、どのように依存関係を解決しますか？", "options": ["グローバル変数を使う", "Providerのコンストラクタで直接インスタンス化する", "`ref` オブジェクトを使って他のProviderを読み取る (`ref.watch` または `ref.read`)", "Providerは互いに依存できない"], "correctAnswer": 2, "explanation": "Providerのコールバック関数内で `ref` オブジェクトを使うことで、他のProviderの値を安全に読み取り、依存関係を構築できます。" },
    { "question": "UI側でProviderの値を読み取るために使われるWidget（またはHook）は何ですか？", "options": ["Provider.of", "ConsumerWidget / Consumer", "StatefulWidget", "すべて正解"], "correctAnswer": 1, "explanation": "Riverpodでは、`ConsumerWidget` を継承するか、`Consumer` Widgetを使うことで、`build` メソッド内で `WidgetRef` (`ref`) を受け取り、Providerを `watch` または `read` できます。" },
    { "question": "`StateProvider` の最も適切な用途は何ですか？", "options": ["APIから取得した複雑なデータ", "ユーザー認証状態", "ソート順序やチェックボックスの状態など、単純で変更可能な状態", "非同期処理"], "correctAnswer": 2, "explanation": "`StateProvider` は、文字列、数値、真偽値といったシンプルな状態を外部から変更できるように公開するのに適しています。" },
    { "question": "Providerの `family` 修飾子は何のために使いますか？", "options": ["Providerをグループ化する", "外部からのパラメータに基づいて、同じ設定で複数のProviderを生成する", "Providerの可視性を制限する", "Providerを継承する"], "correctAnswer": 1, "explanation": "`family` を使うと、例えばユーザーIDをパラメータとして渡し、ユーザーごとに一意の `FutureProvider` や `StateNotifierProvider` を作成できます。" },
    { "question": "Riverpodが `InheritedWidget` ベースのProviderよりも優れているとされる点は何ですか？", "options": ["コンパイル時の安全性（ランタイムエラーの減少）", "ProviderがWidgetツリーから独立している", "より柔軟な依存性注入", "すべて正解"], "correctAnswer": 3, "explanation": "Riverpodは、Providerをグローバルに宣言することで `ProviderNotFoundException` をなくし、コンパイルセーフな方法で依存関係を解決するなど、多くの改良が加えられています。" },
    { "question": "Providerの値を上書き(override)するのは、主にどのような目的ですか？", "options": ["アプリケーションのテーマを変更するため", "テスト中に、Providerをモックや偽のデータに置き換えるため", "パフォーマンスを向上させるため", "Providerの値をリセットするため"], "correctAnswer": 1, "explanation": "テスト時に `ProviderScope` や `ProviderContainer` の `overrides` プロパティを使うことで、特定のProviderの挙動をテスト用の実装に差し替えることができます。" }
  ],
  "a5": [
    { "question": "MVVMアーキテクチャの「VM」は何の略ですか？", "options": ["View-Model", "Virtual-Machine", "View-Manager", "Visual-Model"], "correctAnswer": 0, "explanation": "VMはView-Modelの略です。ViewとModelの間の仲介役として機能します。" },
    { "question": "MVVMにおける「View」の主な責務は何ですか？", "options": ["ビジネスロジックの実行", "データの永続化", "UIの表示とユーザー入力の受付", "APIとの通信"], "correctAnswer": 2, "explanation": "Viewは、UIのレイアウトと表示に責任を持ち、ユーザーからの入力をViewModelに通知します。View自体はビジネスロジックを持ちません。" },
    { "question": "MVVMにおける「ViewModel」の主な責務は何ですか？", "options": ["UI要素を直接操作する", "Viewが表示するための状態(State)を公開し、Viewからの入力を受けてビジネスロジックを実行する", "データベースのテーブルを表現する", "画面遷移を管理する"], "correctAnswer": 1, "explanation": "ViewModelは、Viewが表示に必要なデータや状態をプロパティとして公開します。また、Viewからのイベント（ボタンクリックなど）に応じて、Modelと連携してビジネスロジックを実行します。" },
    { "question": "MVVMにおける「Model」の主な責務は何ですか？", "options": ["UIの状態を保持する", "アプリケーションのビジネスロジックとデータを担当する", "ViewとViewModelを結合する", "ユーザー入力を処理する"], "correctAnswer": 1, "explanation": "Modelは、データ（例: Userオブジェクト）と、そのデータを操作するためのビジネスロジック（例: データの検証、保存）を含みます。UIについては関知しません。" },
    { "question": "ViewとViewModelの間の通信は、どのように行われるのが一般的ですか？", "options": ["ViewModelがViewのメソッドを直接呼び出す", "ViewがViewModelの状態を監視（データバインディング）し、変更に応じてUIを更新する", "グローバルなイベントバスを使う", "ファイルI/Oを使う"], "correctAnswer": 1, "explanation": "ViewはViewModelが公開する状態（例: `Stream` や `StateNotifier`）を監視します。ViewModelの状態が変化すると、Viewは自動的に更新されます。これにより、ViewとViewModelは疎結合に保たれます。" },
    { "question": "MVVMアーキテクチャの主な利点は何ですか？", "options": ["コードの記述量が最も少なくなる", "UIとビジネスロジックの分離による、テスト容易性と保守性の向上", "ビルドが最も速くなる", "すべてのロジックが1つのファイルにまとまる"], "correctAnswer": 1, "explanation": "各層が明確な責務を持つため、ロジック部分（ViewModel, Model）をUIから切り離して単体テストしたり、UI部分（View）を独立して変更したりすることが容易になります。" },
    { "question": "FlutterでMVVMを実装する場合、ViewModelはどの状態管理ライブラリと組み合わせることができますか？", "options": ["ChangeNotifier (Provider)", "StateNotifier (Riverpod)", "Bloc/Cubit (flutter_bloc)", "すべて可能"], "correctAnswer": 3, "explanation": "MVVMは設計パターンであり、特定の実装に依存しません。ViewModelの役割は、`ChangeNotifier`, `StateNotifier`, `Cubit` など、状態を公開できる様々なクラスで実現できます。" },
    { "question": "ViewModelからViewにイベント（例:「保存が完了しました」という通知）を伝えるには、どのような方法が考えられますか？", "options": ["ViewModelにUIの状態を持たせる", "ViewModelが `Stream` を公開し、Viewがそれをリッスンする", "ViewModelがViewのインスタンスを直接参照する", "グローバル変数で通知する"], "correctAnswer": 1, "explanation": "UIの再構築を伴わない一度きりのイベントを伝えるには、`Stream`（例: `StreamController.broadcast()`）をViewModelに持たせ、View側でリッスンするのが一般的です。これにより、責務の分離が保たれます。" },
    { "question": "ユーザーがボタンをクリックしたときの処理の流れとして、MVVMで最も適切なものはどれですか？", "options": ["View → Model → ViewModel", "View → ViewModel → Model", "Model → View → ViewModel", "ViewModel → View → Model"], "correctAnswer": 1, "explanation": "1. Viewがユーザーのクリックイベントを受け取る。 2. ViewがViewModelの対応するメソッドを呼び出す。 3. ViewModelが必要に応じてModelのロジックを呼び出し、自身の状態を更新する。 4. ViewはViewModelの状態変化を監視しているため、自動的にUIが更新される。" },
    { "question": "MVVMと他のアーキテクチャ（例: MVC, MVP）との主な違いは何ですか？", "options": ["MVVMだけが3つの層を持つ", "データバインディングによるViewとViewModelの疎結合な連携", "MVVMはモバイルアプリ専用である", "MVVMはテストが書けない"], "correctAnswer": 1, "explanation": "MVVMの最大の特徴は、データバインディング機構（FlutterではStreamやNotifierの監視）を通じて、ViewModelがViewを直接参照することなくUIを更新できる点にあります。これにより、より高い疎結合性を実現します。" }
  ],
  "ad1": [
      { "question": "単一の関数やクラスのロジックを検証するテストはどれですか？", "options": ["ウィジェットテスト", "統合テスト", "単体テスト", "E2Eテスト"], "correctAnswer": 2, "explanation": "単体テストは、UIや外部依存から切り離して、特定のロジックを検証します。" },
      { "question": "Widgetのレンダリングやインタラクションをテストするのはどれですか？", "options": ["単体テスト", "ウィジェットテスト", "統合テスト", "CI/CD"], "correctAnswer": 1, "explanation": "ウィジェットテストは、個々のWidgetが期待通りに動作するかを検証します。" },
      { "question": "TDD (テスト駆動開発) の基本的なサイクルとして正しい順序はどれですか？", "options": ["レッド→グリーン→リファクタ", "グリーン→レッド→リファクタ", "リファクタ→レッド→グリーン", "レッド→リファクタ→グリーン"], "correctAnswer": 0, "explanation": "TDDでは、1. 失敗するテストを書く(レッド)、2. テストをパスさせる最小限のコードを書く(グリーン)、3. コードをクリーンにする(リファクタ)というサイクルを繰り返します。" },
      { "question": "ウィジェットテストで、特定のWidgetを見つけるために使われるオブジェクトは何ですか？", "options": ["WidgetTester", "Finder", "Matcher", "TestWidget"], "correctAnswer": 1, "explanation": "`find` オブジェクト（例: `find.byType(MyWidget)`, `find.text('Hello')`）を使って、テスト対象のWidgetをツリー内から検索します。" },
      { "question": "外部の依存関係（例: APIクライアント）をテスト中に偽のオブジェクトに置き換える手法を何と呼びますか？", "options": ["スタビング", "モッキング", "フェイキング", "すべて正解"], "correctAnswer": 1, "explanation": "モッキングは、テスト対象が依存するオブジェクトの振る舞いを模倣した偽物（モック）に置き換えることで、テストを独立させ、予測可能にするためのテクニックです。`mockito` パッケージがよく使われます。" },
      { "question": "ウィジェットテストで、ボタンのタップなどのユーザー操作をシミュレートするには、`WidgetTester` のどのメソッドを使いますか？", "options": ["press()", "click()", "tap()", "enterText()"], "correctAnswer": 2, "explanation": "`await tester.tap(find.byType(ElevatedButton))` のように `tap()` メソッドを使って、Widgetへのタップイベントを発生させます。" },
      { "question": "テストの最後に、期待される結果と実際の結果が一致するかを検証するために使われる関数は何ですか？", "options": ["verify()", "expect()", "assert()", "check()"], "correctAnswer": 1, "explanation": "`expect(actual, matcher)` 関数を使って、実際の値が期待通りの値（または状態）であるかを検証します。例えば `expect(find.text('Success'), findsOneWidget)` のように使います。" },
      { "question": "複数のWidgetやサービスが連携して動作することを検証するテストは何ですか？", "options": ["単体テスト", "ウィジェットテスト", "統合テスト", "受け入れテスト"], "correctAnswer": 2, "explanation": "統合テストは、アプリの一部（例: 画面とViewModel）や、アプリ全体が外部サービス（データベース、APIなど）と連携して正しく動作するかを検証します。" },
      { "question": "`WidgetTester.pumpAndSettle()` は何をしますか？", "options": ["テストを即座に終了する", "すべてのアニメーションや非同期処理が完了するまでフレームを進める", "Widgetツリーを再構築する", "エラーを発生させる"], "correctAnswer": 1, "explanation": "`pumpAndSettle()` は、画面遷移のアニメーションや `Future` の完了など、すべてのフレーム描画活動が落ち着くまでテストを待機させます。" },
      { "question": "テストコードを配置するのに最も適切なディレクトリはどこですか？", "options": ["`lib/`", "`assets/`", "`test/`", "プロジェクトのルートディレクトリ"], "correctAnswer": 2, "explanation": "Flutterプロジェクトでは、すべてのテストコードはプロジェクトルートにある `test/` ディレクトリに配置するのが規約です。" }
  ]
}